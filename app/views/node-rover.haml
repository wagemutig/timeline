%div.project__unsemanticContentWrapper
  %header.project__header
    %a{:href => '/', :class => "close__project"}
      &times;
    %h1 Node-Rover
    %div.project__unsemanticImageWrapper
      %img{:src => "../img/node-rover_cover.png", :alt => "Node-Rover Cover", :class => "project__cover"}
    %article.project__article
      %p.article__paragraph
        Node-Rover ist ein voll funktionsfähiger, teilautonomer Roboter der mit jedem vorstellbaren Web-fähigen Device von MacBook bis iPhone gesteuert werden kann. Dabei kommuniziert der Client – zum Beispiel ein iPhone – über einen Node.js Server mit dem Node-Rover. Der Node-Rover ist extrem reaktiv. Mittels der Raupen kann er sich selbst über Hindernisse bewegen, die Klaue erlaubt es ihm Gegenstände zu greifen und gar zu Transportieren. Ausserdem ist ein zweiachsig steuerbarer Kameraturm installiert. Auch die Server-Technologie zum Video-Stream steht bereit, leider reichte das Budget nicht mehr für eine IP-Kamera. Dies macht aber die Twitter-Integration wett.

  %main
    %section.project__section
      %article.project__article
        %h3.section__title
          Trello Board
        %p.article__paragraph
          Als Team von fünf Studenten unterschiedlichster Backgrounds waren wir uns bewusst, dass Kollaboration und Kommunikation über den Erfolg des Projekts entscheiden würden. So entschieden wir uns nebst dem Version Control System Github auch die Agile Kanban Boards der Web App Trello zu nutzen. Ein guter Entscheid!
      %img{:src => "../img/node-rover_trello.png", :alt => "Node-Rover Trello Board", :class => "section__image"}

    %section.project__section
      %article.project__article
        %h3.section__title
          Wireframes
        %p.article__paragraph
          Dank intensivster Recherche und Explorations-Phase und dem Testen verschiedenster Ferngesteuerter Spielzeuge war mir rasch klar wie die Benutzeroberfläche des Node-Rover RC GUI (Remote Control Graphic User Interface) sich anzufühlen hat und ich zeichnete einen ersten Mockup in Sketch.
      %img{:src => "../img/node-rover_wireframes.png", :alt => "Node-Rover Wireframes", :class => "section__image"}

    %section.project__section
      %article.project__article
        %h3.section__title
          Mockup
        %p.article__paragraph
          Das Mockup hielt sich weitestgehend ans Wireframe, allerdings entschied das Team meinen Vorschlag keine Pixelgrafiken zu verwenden zu implementieren. Dies sollte sich später als erheblichen Mehraufwand für mich herausstellen. Hat sich aber gelohnt!
      %img{:src => "../img/node-rover_mockups.png", :alt => "Node-Rover Mockup", :class => "section__image"}

    %section.project__section
      %article.project__article
        %h3.section__title
          Code
        %p.article__paragraph
          Nebst der Robotik und Elektronik lebt der Node-Rover gerade eben vom Code. Wir konnten uns auf relativ ausgereifte Libraries wie Johnny5 verlassen. Jedoch stiessen wir damit an als wenn es darum ging den Node-Rover kabellos zu steuern. So implementierten wir die benötigten Teile aus der Johnny5 Library eben in Arduino Flavour C und lernten so nebenbei noch eine neue Programmiersprache. So lag der Serielle Code nun auf dem Arduino selbst und der Server steuerte nur noch die Kommunikation. Hier noch etwas mehr zum Code dieses Projekts. Selbstverständlich ist auch hier wieder der gesamte Source Code des Projekts frei auf Github zugänglich.
        %pre.section__code
          %code
            it('should emit forward', function(done){
            var socket = io.connect(url, options);
            socket.once('forward', function(msg){
            expect(msg).to.eql('moving forward');
            done();
            });
            socket.emit('forward');
            });
        %p.article__paragraph
          Wie alle Projekte die bei der Maker Academy entstanden ist auch Node-Rover durchgehend nach den Test Driven Development  und Behaviour Driven Development Paradigmen geschrieben. Dabei stellte das Testen der Websockets eine besondere Herausforderung dar, die wir mit Mocks und Stubs lösten.
        %pre.section__code
          %code
            <g id="move-right" class="control" transform="translate(120, 72)">
            <path d="M20.6,12.2 C18.5,13.6 15.1,14.5 11.2,14.5 C4.8,14.5 -0.4,12 -0.4,9 C-0.4,6 4.8,3.5 11.2,3.5 C14.9,3.5 18.2,4.3 20.3,5.6 L13,-0.4" id="Shape" stroke="#FFFFFF" stroke-width="2"></path>
            <ellipse id="Oval" fill="#FFFFFF" cx="10.8" cy="8.7" rx="1.8" ry="0.7"></ellipse>
            <circle class="uns-control" data-action="move-right" r="30" stroke-width="0" transform="translate(10, 10)" ></circle>
            </g>
        %p.article__paragraph
          Für mich persönlich stellte insbesondere das Frontend eine grosse Herausforderung dar. Nebst meinem sonstigen Mitwirken am Projekt – bei Makers berührt stehts jedes Team-Mitglied alle Teile des Codes – konnte ich den Konzeptionellen, Gestalterischen wie auch den Technischen Part der Grafischen Benutzeroberfläche – RC GUI – selbst umsetzen. Wir entschieden uns getreu aktueller Web-Trends dazu keine Pixelgrafiken zu verwenden. Somit setzte ich die Icons der Benutzeroberfläche als reine SVGs, Vektorgrafiken um. Die Koordinaten habe ich meist von Hand aus der Vektor-Software Sketch in Code übersetzt.
        %p.article__paragraph
          Um Latenzen auf einem absoluten Minimum zu halten verwendeten wir zur Kommunikation zwischen Server, Client und Node-Rover Websockets.
        %pre.section__code
          %code
            if(b == 'o'){
            for(aPos; aPos < 100; aPos++) {
            b = Serial.read();
            if (b == 's' || b == 'l') {
            arm.write(aPos);
            break;
            } 
            arm.write(aPos);               
            delay(15);                       
            }; 
            };
        %p.article__paragraph
          Der Arduino Flavour C Code für die Steuerung einer der vier Antriebs-Servos.
        %pre.section__code
          %code
            if (wifly.isConnected() == false) {
            Serial.println("Connecting");
            if (wifly.open(site, 1337)) {
            Serial.println("Connected");
            connectTime = millis();
            } else {
            Serial.println("Failed to open");
            }
        %p.article__paragraph
          Die Integration des Wi-Fly Chips erm&ouml;glichte es uns den Node-Rover kabellos zu steuern. Gleichzeitig stellte dies die wohl gr%ouml;sste Herausforderung des Projekts dar. 
        %pre.section__code
          %code
            TwitterControl.prototype.controlFinder = function(tweet) {
            if(tweet === 'forward') _this.transmitToArduino('w');
            else if(tweet === 'left') _this.transmitToArduino('a');
            else if(tweet === 'right') _this.transmitToArduino('d');
            else if(tweet === 'reverse') _this.transmitToArduino('r');
            else if(tweet === 'brake') _this.transmitToArduino('s');
            };
        %p.article__paragraph 
          Eines der Beliebtesten Features des Node-Rovers war wohl die Twitter-Integration. Ist der Server live hat der Node-Rover seinen eigenen Twitter Account und hört auf ihm zugetwitterte Befehle im Stil von @node-rover #right. Als alle im Raum ihr Smartphone hervornamen und mit etwas Verzögerung den Rover im Kollektiv navigierten das sorgte für grossen Begeisterung bei der Präsentation. 
